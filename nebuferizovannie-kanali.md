Небуферизованные каналы

Операция отправления в небуферизованный канал плокирует горутину до тех пор, пока другая горутина не выполнить соответствующее получение из того же канала, после чего значение становится переданным, и обе горутины продолжаются. И наоборот, если первой сделана попытка выполнить получения, принимающая горутина блокируется до тех пор, пока другая горутина не выполнить отправление значения в тот же канал.

Связь по небуферизованному каналу приводит к **синхронизации** операций отплавления и получения.

**Получение** значения **предшествует** продолжению работы **отправляющей** горутины.

```
func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // Примечание: игнорируем ошибки
        log.PrintIn("будет напечатано до завершения main() ")
        done <- struct{}{} // Сигнал главной go-подпрограмме
    }()
    mustCopy(conn, os.Stdin)
    conn.CloseQ
    <-done // ждет пока не выполниться done <- struct{}{}
```



