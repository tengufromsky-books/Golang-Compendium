## Inside Channels

внутри каналы устроены следующим образом

[http://dmitryvorobev.blogspot.com.es/2016/08/golang-channels-implementation.html](http://dmitryvorobev.blogspot.com.es/2016/08/golang-channels-implementation.html)

![](https://d33ypg4xwx0n86.cloudfront.net/direct?url=https%3A%2F%2Fhabrastorage.org%2Ffiles%2F483%2F025%2F741%2F48302574178048caac81c816f9e37238.png&resize=w640)

qcount - количество элементов в буфереля

dataqsiz -  размерность буфера

buf - указатель на буфер для элементов канала

closed -флаг, указывающий закрыт канал или нет

recvq - указатель на связанный список горутин , ожидающих чтения из канала

sendq - указатель на связанный список горутин, ожидающих запись в канал

lock - мьютекс для безопасного доступа к каналу

В общем случае, горутина захватывает мутекс при любом действии с каналом, кроме lock-free проверок при неблокирующих выховах

Го не выделяет буфер для синхронных каналов, поэтому укзатель на буфер равенн nil и dataqsiz равен нулю

```
package main

func main() {
    ch := make(chan bool)
    go func() {
        ch <- true
    }()
    <-ch
}
```

В приведённом коде нет гарантии, что случится первее — **чтение **из канала или **запись**, поэтому допустим, что первым действием будет **чтение **из канала \(обратный пример, когда вначале идёт запись, будет рассмотрена ниже в примере с буферизированным каналами\). Вначале, текущая горутина произведёт некоторые проверки, такие как: закрыт ли канал, буферизирован он или нет, содержит ли гоуртины в send-очереди.

в этом примере у канала нет буфера и ожидающих отправки горутин, поэтому горутина добавит сама себя в recqv и заблокируется.

![](https://d33ypg4xwx0n86.cloudfront.net/direct?url=https%3A%2F%2Fhabrastorage.org%2Ffiles%2F2af%2Fb2c%2F796%2F2afb2c79621847e0a28f118f92ed5c10.png&resize=w640)

у нас осталась только одна работающая горутина, которая пытается записать данные в канал. Все проверки повторяются снова, и когда горутина проверяет

`recvq`

очередь, она находит ожидающую чтение горутину, удаляет её из очереди, **записывает данные в её стек** и снимает блокировку. Это **единственное **место во всём рантайме Go, когда одна горутина пишет напрямую в стек другой горутины.



### буферизованные каналы

```
func main() {
    ch := make(chan bool, 1)
    ch <- true
    go func() {
        <-ch
    }()
    ch <- true
}
```

Порядок исполнения снова неизвестен, однако допустим что два значения были записаны в канал и после этого один из элементов вычитан

![](https://d33ypg4xwx0n86.cloudfront.net/direct?url=https%3A%2F%2Fhabrastorage.org%2Ffiles%2F6f4%2Fe78%2F6af%2F6f4e786af89b47f49e0b52d1869a2180.png&resize=w640)

разница с синхронным каналов в том, что тут dataqsiz установлен в 1 и выделен буфер соответсвующео размера

Перед записью первого значения горутина проверит пустоту очереди recqv, пустоту буферу, достаточно ли места в буфере. ВСе в порядке, горутина пишет значение в буфер, увеличает qcount  и продолжает исполнение. 

