## Inside Channels

внутри каналы устроены следующим образом

[http://dmitryvorobev.blogspot.com.es/2016/08/golang-channels-implementation.html](http://dmitryvorobev.blogspot.com.es/2016/08/golang-channels-implementation.html)

![](https://d33ypg4xwx0n86.cloudfront.net/direct?url=https%3A%2F%2Fhabrastorage.org%2Ffiles%2F483%2F025%2F741%2F48302574178048caac81c816f9e37238.png&resize=w640)

qcount - количество элементов в буфереля

dataqsiz -  размерность буфера

buf - указатель на буфер для элементов канала

closed -флаг, указывающий закрыт канал или нет

recvq - указатель на связанный список горутин , ожидающих чтения из канала

sendq - указатель на связанный список горутин, ожидающих запись в канал

lock - мьютекс для безопасного доступа к каналу



В общем случае, горутина захватывает мутекс при любом действии с каналом, кроме lock-free проверок при неблокирующих выховах 

Го не выделяет буфер для синхронных каналов, поэтому укзатель на буфер равенн nil и dataqsiz равен нулю

```
package main

func main() {
    ch := make(chan bool)
    go func() {
        ch <- true
    }()
    <-ch
}
```

В приведённом коде нет гарантии, что случится первее — чтение из канала или запись, поэтому допустим, что первым действием будет чтение из канала \(обратный пример, когда вначале идёт запись, будет рассмотрена ниже в примере с буферизированным каналами\). Вначале, текущая горутина произведёт некоторые проверки, такие как: закрыт ли канал, буферизирован он или нет, содержит ли гоуртины в send-очереди.

в этом примере у канала нет буфера и ожидающих отправки горутин, поэтому горутина добавит сама себя в recqv и заблокируется.

![](https://d33ypg4xwx0n86.cloudfront.net/direct?url=https%3A%2F%2Fhabrastorage.org%2Ffiles%2F2af%2Fb2c%2F796%2F2afb2c79621847e0a28f118f92ed5c10.png&resize=w640)



